diff -ruN .gitignore .gitignore
--- .gitignore	1970-01-01 02:00:00.000000000 +0200
+++ .gitignore	2024-08-27 15:04:46.089756110 +0300
@@ -0,0 +1,2 @@
+*
+!.gitignore
\ No newline at end of file
diff -ruN lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol
--- lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol	2024-08-27 17:10:27.889569455 +0300
+++ lib/solidity-utils/lib/openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/ERC4626Upgradeable.sol	2024-08-27 15:06:23.055328402 +0300
@@ -56,6 +56,8 @@
         IERC20 _asset;
         uint8 _underlyingDecimals;
     }
+    IERC20 _asset;
+    uint8 _underlyingDecimals;
 
     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ERC4626")) - 1)) & ~bytes32(uint256(0xff))
     bytes32 private constant ERC4626StorageLocation = 0x0773e532dfede91f04b12a73d3d2acd361424f41f76b4fb79f090161e36b4e00;
@@ -96,8 +98,8 @@
     function __ERC4626_init_unchained(IERC20 asset_) internal onlyInitializing {
         ERC4626Storage storage $ = _getERC4626Storage();
         (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);
-        $._underlyingDecimals = success ? assetDecimals : 18;
-        $._asset = asset_;
+        /*$.*/_underlyingDecimals = success ? assetDecimals : 18;
+        /*$.*/_asset = asset_;
     }
 
     /**
@@ -125,19 +127,19 @@
      */
     function decimals() public view virtual override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {
         ERC4626Storage storage $ = _getERC4626Storage();
-        return $._underlyingDecimals + _decimalsOffset();
+        return /*$.*/_underlyingDecimals + _decimalsOffset();
     }
 
     /** @dev See {IERC4626-asset}. */
     function asset() public view virtual returns (address) {
         ERC4626Storage storage $ = _getERC4626Storage();
-        return address($._asset);
+        return address(/*$.*/_asset);
     }
 
     /** @dev See {IERC4626-totalAssets}. */
     function totalAssets() public view virtual returns (uint256) {
         ERC4626Storage storage $ = _getERC4626Storage();
-        return $._asset.balanceOf(address(this));
+        return /*$.*/_asset.balanceOf(address(this));
     }
 
     /** @dev See {IERC4626-convertToShares}. */
@@ -272,7 +274,7 @@
         // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the
         // assets are transferred and before the shares are minted, which is a valid state.
         // slither-disable-next-line reentrancy-no-eth
-        SafeERC20.safeTransferFrom($._asset, caller, address(this), assets);
+        SafeERC20.safeTransferFrom(/*$.*/_asset, caller, address(this), assets);
         _mint(receiver, shares);
 
         emit Deposit(caller, receiver, assets, shares);
@@ -300,7 +302,7 @@
         // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the
         // shares are burned and after the assets are transferred, which is a valid state.
         _burn(owner, shares);
-        SafeERC20.safeTransfer($._asset, receiver, assets);
+        SafeERC20.safeTransfer(/*$.*/_asset, receiver, assets);
 
         emit Withdraw(caller, receiver, owner, assets, shares);
     }
diff -ruN src/periphery/contracts/static-a-token/ERC20AaveLMUpgradeable.sol src/periphery/contracts/static-a-token/ERC20AaveLMUpgradeable.sol
--- src/periphery/contracts/static-a-token/ERC20AaveLMUpgradeable.sol	2024-08-27 17:10:27.983574137 +0300
+++ src/periphery/contracts/static-a-token/ERC20AaveLMUpgradeable.sol	2024-08-27 15:20:35.957439490 +0300
@@ -25,6 +25,10 @@
     mapping(address user => RewardIndexCache cache) _startIndex;
     mapping(address user => mapping(address reward => UserRewardsData cache)) _userRewardsData;
   }
+  address _referenceAsset; // a/v token to track rewards on INCENTIVES_CONTROLLER
+  address[] _rewardTokens;
+  mapping(address user => RewardIndexCache cache) _startIndex;
+  mapping(address user => mapping(address reward => UserRewardsData cache)) _userRewardsData;
 
   // keccak256(abi.encode(uint256(keccak256("aave-dao.storage.ERC20AaveLM")) - 1)) & ~bytes32(uint256(0xff))
   bytes32 private constant ERC20AaveLMStorageLocation =
@@ -47,7 +51,7 @@
   }
   function __ERC20AaveLM_init_unchained(address referenceAsset_) internal onlyInitializing {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    $._referenceAsset = referenceAsset_;
+    /*$.*/_referenceAsset = referenceAsset_;
 
     if (INCENTIVES_CONTROLLER != IRewardsController(address(0))) {
       refreshRewardTokens();
@@ -81,7 +85,7 @@
   ///@inheritdoc IERC20AaveLM
   function refreshRewardTokens() public override {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    address[] memory rewards = INCENTIVES_CONTROLLER.getRewardsByAsset($._referenceAsset);
+    address[] memory rewards = INCENTIVES_CONTROLLER.getRewardsByAsset(/*$.*/_referenceAsset);
     for (uint256 i = 0; i < rewards.length; i++) {
       _registerRewardToken(rewards[i]);
     }
@@ -95,7 +99,7 @@
 
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
     address[] memory assets = new address[](1);
-    assets[0] = address($._referenceAsset);
+    assets[0] = address(/*$.*/_referenceAsset);
 
     return INCENTIVES_CONTROLLER.claimRewards(assets, type(uint256).max, address(this), reward);
   }
@@ -103,7 +107,7 @@
   ///@inheritdoc IERC20AaveLM
   function isRegisteredRewardToken(address reward) public view override returns (bool) {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    return $._startIndex[reward].isRegistered;
+    return /*$.*/_startIndex[reward].isRegistered;
   }
 
   ///@inheritdoc IERC20AaveLM
@@ -112,7 +116,7 @@
       return 0;
     }
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    (, uint256 nextIndex) = INCENTIVES_CONTROLLER.getAssetIndex($._referenceAsset, reward);
+    (, uint256 nextIndex) = INCENTIVES_CONTROLLER.getAssetIndex(/*$.*/_referenceAsset, reward);
     return nextIndex;
   }
 
@@ -124,7 +128,7 @@
 
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
     address[] memory assets = new address[](1);
-    assets[0] = $._referenceAsset;
+    assets[0] = /*$.*/_referenceAsset;
     uint256 freshRewards = INCENTIVES_CONTROLLER.getUserRewards(assets, address(this), reward);
     return IERC20(reward).balanceOf(address(this)) + freshRewards;
   }
@@ -137,19 +141,19 @@
   ///@inheritdoc IERC20AaveLM
   function getUnclaimedRewards(address user, address reward) external view returns (uint256) {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    return $._userRewardsData[user][reward].unclaimedRewards;
+    return /*$.*/_userRewardsData[user][reward].unclaimedRewards;
   }
 
   ///@inheritdoc IERC20AaveLM
   function getReferenceAsset() external view returns (address) {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    return $._referenceAsset;
+    return /*$.*/_referenceAsset;
   }
 
   ///@inheritdoc IERC20AaveLM
   function rewardTokens() external view returns (address[] memory) {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    return $._rewardTokens;
+    return /*$.*/_rewardTokens;
   }
 
   /**
@@ -159,8 +163,8 @@
    */
   function _update(address from, address to, uint256 amount) internal virtual override {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    for (uint256 i = 0; i < $._rewardTokens.length; i++) {
-      address rewardToken = address($._rewardTokens[i]);
+    for (uint256 i = 0; i < /*$.*/_rewardTokens.length; i++) {
+      address rewardToken = address(/*$.*/_rewardTokens[i]);
       uint256 rewardsIndex = getCurrentRewardsIndex(rewardToken);
       if (from != address(0)) {
         _updateUser(from, rewardsIndex, rewardToken);
@@ -182,14 +186,14 @@
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
     uint256 balance = balanceOf(user);
     if (balance > 0) {
-      $._userRewardsData[user][rewardToken].unclaimedRewards = _getClaimableRewards(
+      /*$.*/_userRewardsData[user][rewardToken].unclaimedRewards = _getClaimableRewards(
         user,
         rewardToken,
         balance,
         currentRewardsIndex
       ).toUint128();
     }
-    $._userRewardsData[user][rewardToken].rewardsIndexOnLastInteraction = currentRewardsIndex
+    /*$.*/_userRewardsData[user][rewardToken].rewardsIndexOnLastInteraction = currentRewardsIndex
       .toUint128();
   }
 
@@ -226,12 +230,12 @@
     uint256 currentRewardsIndex
   ) internal view returns (uint256) {
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    RewardIndexCache memory rewardsIndexCache = $._startIndex[reward];
+    RewardIndexCache memory rewardsIndexCache = /*$.*/_startIndex[reward];
     if (!rewardsIndexCache.isRegistered) {
       revert RewardNotInitialized(reward);
     }
 
-    UserRewardsData memory currentUserRewardsData = $._userRewardsData[user][reward];
+    UserRewardsData memory currentUserRewardsData = /*$.*/_userRewardsData[user][reward];
     return
       currentUserRewardsData.unclaimedRewards +
       _getPendingRewards(
@@ -279,7 +283,7 @@
       }
       if (userReward > 0) {
         ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-        $._userRewardsData[onBehalfOf][rewards[i]].unclaimedRewards = unclaimedReward.toUint128();
+        /*$.*/_userRewardsData[onBehalfOf][rewards[i]].unclaimedRewards = unclaimedReward.toUint128();
         $
         ._userRewardsData[onBehalfOf][rewards[i]]
           .rewardsIndexOnLastInteraction = currentRewardsIndex.toUint128();
@@ -297,8 +301,8 @@
     uint256 startIndex = getCurrentRewardsIndex(reward);
 
     ERC20AaveLMStorage storage $ = _getERC20AaveLMStorage();
-    $._rewardTokens.push(reward);
-    $._startIndex[reward] = RewardIndexCache(true, startIndex.toUint240());
+    /*$.*/_rewardTokens.push(reward);
+    /*$.*/_startIndex[reward] = RewardIndexCache(true, startIndex.toUint240());
 
     emit RewardTokenRegistered(reward, startIndex);
   }
diff -ruN src/periphery/contracts/static-a-token/ERC4626StataTokenUpgradeable.sol src/periphery/contracts/static-a-token/ERC4626StataTokenUpgradeable.sol
--- src/periphery/contracts/static-a-token/ERC4626StataTokenUpgradeable.sol	2024-08-27 17:10:27.983574137 +0300
+++ src/periphery/contracts/static-a-token/ERC4626StataTokenUpgradeable.sol	2024-08-27 15:13:24.493556471 +0300
@@ -26,6 +26,7 @@
   struct ERC4626StataTokenStorage {
     IERC20 _aToken;
   }
+  IERC20 _aToken;
 
   // keccak256(abi.encode(uint256(keccak256("aave-dao.storage.ERC4626StataToken")) - 1)) & ~bytes32(uint256(0xff))
   bytes32 private constant ERC4626StataTokenStorageLocation =
@@ -66,7 +67,7 @@
     IERC20 aTokenUnderlying = IERC20(IAToken(newAToken).UNDERLYING_ASSET_ADDRESS());
 
     ERC4626StataTokenStorage storage $ = _getERC4626StataTokenStorage();
-    $._aToken = IERC20(newAToken);
+    /*$.*/_aToken = IERC20(newAToken);
 
     SafeERC20.forceApprove(aTokenUnderlying, address(POOL), type(uint256).max);
 
@@ -90,7 +91,7 @@
     bool depositToAave
   ) public returns (uint256) {
     IERC20Permit assetToDeposit = IERC20Permit(
-      depositToAave ? asset() : address(_getERC4626StataTokenStorage()._aToken)
+      depositToAave ? asset() : address(/*_getERC4626StataTokenStorage().*/_aToken)
     );
 
     try
@@ -113,7 +114,7 @@
   ///@inheritdoc IERC4626StataToken
   function aToken() public view returns (IERC20) {
     ERC4626StataTokenStorage storage $ = _getERC4626StataTokenStorage();
-    return $._aToken;
+    return /*$.*/_aToken;
   }
 
   ///@inheritdoc IERC4626
@@ -205,7 +206,7 @@
       POOL.deposit(cachedAsset, assets, address(this), 0);
     } else {
       ERC4626StataTokenStorage storage $ = _getERC4626StataTokenStorage();
-      SafeERC20.safeTransferFrom($._aToken, caller, address(this), assets);
+      SafeERC20.safeTransferFrom(/*$.*/_aToken, caller, address(this), assets);
     }
     _mint(receiver, shares);
 
@@ -244,7 +245,7 @@
       POOL.withdraw(asset(), assets, receiver);
     } else {
       ERC4626StataTokenStorage storage $ = _getERC4626StataTokenStorage();
-      SafeERC20.safeTransfer($._aToken, receiver, assets);
+      SafeERC20.safeTransfer(/*$.*/_aToken, receiver, assets);
     }
 
     emit Withdraw(caller, receiver, owner, assets, shares);
